#include "arduino.ceu"

native do
    ##include "EEPROM.h"
    ##include "SPI.h"
    ##include "GD2.h"
    ##define NBLOBS 128
    ##define OFFSCREEN -16384
    struct xy {
        int x, y;
    } blobs[NBLOBS];

    static byte blob_i;
end


input void GD_REDRAW;

var int i;

par/or do
    /* Setup */
_GD.begin();
    finalize with
     _GD.finish();
    end

    i=0;

    loop do
        if(i == _NBLOBS) then
            break;
        end
        _blobs[i].x = _OFFSCREEN;
        _blobs[i].y = _OFFSCREEN;

        i = i + 1;
    end

    loop do
        async do
            emit GD_REDRAW; // REDRAW every loop iteration, after other events.
        end
    end
with
    par/or do
        // Get the touch coordinates and store in array
        _GD.get_inputs();
        if (_GD.inputs.x != -32768) then
            _blobs[_blob_i].x = _GD.inputs.x << 4;
            _blobs[_blob_i].y = _GD.inputs.y << 4;
        else
            _blobs[_blob_i].x = _OFFSCREEN;
            _blobs[_blob_i].y = _OFFSCREEN;
        end
        _blob_i = (_blob_i + 1) & (_NBLOBS - 1);
    with
        // draws the blobs on screen
        every GD_REDRAW do
            _GD.ClearColorRGB(0xe0e0e0);
            _GD.Clear();

            _GD.Begin(_POINTS);
            i = 0;

            loop do
                if(i == _NBLOBS) then
                    break;
                end
                _blobs[i].x = _OFFSCREEN;
                _blobs[i].y = _OFFSCREEN;

                i = i + 1;

                _GD.ColorA(i << 1);
                _GD.PointSize((1024 + 16) - (i << 3));

                // Random color for each blob, keyed from (blob_i + i)
                var u8 j = (_blob_i + i) & (_NBLOBS - 1);
                var u8 r = j * 17;
                var u8 g = j * 23;
                var u8 b = j * 147;
                _GD.ColorRGB(r, g, b);

                // Draw it!
                _GD.Vertex2f(_blobs[j].x, _blobs[j].y);
            end

            _GD.swap();
        end
    end
end
