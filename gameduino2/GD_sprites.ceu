#define NSPRITES 5
#define TIM 20

input void GD_REDRAW;

class Sprite with
    var byte i;        // each sprite has a different incremental "i"
do
    var byte t = i;
    var int v = _pgm_read_dword(_sprites + i);
    //_Serial.println("class");
    loop j in TIM do          
        await GD_REDRAW;
        _Serial.println("Class");
        _GD.Begin(_BITMAPS);
        var int r = _pgm_read_dword(_circle + t);
        _GD.cmd32(v + r);
        t = t + 1;
    end
end

_Serial.begin(9600);


par/or do
	_Serial.println("trail1");
	#include "gd.ceu"
with
	_Serial.println("trail2");
    native do
    	#include "sprites_assets.h"
	end
	_LOAD_ASSETS();
	_Serial.println("trail2end");
	_GD.Clear();
	
	// display number of sprites
    every GD_REDRAW do
        _GD.Clear();
        _GD.ColorRGB(0x000000);
        
		_GD.ColorA(140);
		_GD.LineWidth(28 * 16);
		_GD.Begin(_LINES);
		_GD.Vertex2ii(240 - 110, 136, 0, 0);
		_GD.Vertex2ii(240 + 110, 136, 0, 0);
		_GD.RestoreContext();

		_GD.cmd_number(215, 110, 31, _OPT_RIGHTX, 5);   // printing 5 always temporarily
		_GD.cmd_text(229, 110, 31, 0, "sprites");
    end
with
	_Serial.println("trail3");
    pool Sprite[NSPRITES] sprites;
    var byte i = 0;   // incremental "i" for blobs
    
    // spawn a new sprite with incremental i.
    every GD_REDRAW do
        spawn Sprite in sprites with
            _.i = i;  // a new blob
        end;
        i = (i + 1) % NSPRITES; 
    end
with
	_Serial.println("trail4");
    every GD_REDRAW do
        _GD.swap();
        //_GD.Clear();
    end
end

_Serial.println("end");

